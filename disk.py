#!/usr/bin/env python3
"""disk.py — disk health, format, and progress monitoring tool."""

from __future__ import annotations

import argparse
import logging
import os
import re
import select
import shutil
import subprocess
import sys
import termios
import time
import tty
from pathlib import Path

PORTS = [
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy6-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy4-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy11-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy9-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy5-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy3-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy10-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy8-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy2-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy7-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy16-lun-0",
    "/dev/disk/by-path/pci-<PCI_ADDR>-sas-exp0x<EXPANDER_WWN>-phy17-lun-0",
]

SLOTS = [2, 5, 8, 11, 1, 4, 7, 10, 0, 3, 6, 9]
PORT_TO_SLOT = dict(zip(PORTS, SLOTS))

HDSENTINEL = "/root/HDSentinel"
LOGFILE    = "/var/log/diskops.log"

_log = logging.getLogger("diskops")
_log.setLevel(logging.INFO)
try:
    _log.addHandler(logging.FileHandler(LOGFILE))
except PermissionError:
    pass

def log(msg: str) -> None:
    _log.info(msg)

_TTY = sys.stdout.isatty()
GRN = "\033[32m"; BGRN = "\033[1;32m"; YLW = "\033[33m"; RED = "\033[31m"
CYN = "\033[36m"; BCYN = "\033[1;36m"; WHT = "\033[37m"; RST = "\033[0m"

def _a(code: str, t: str) -> str:
    return f"\033[{code}m{t}\033[0m" if _TTY else t

def bold(t: str) -> str: return _a("1", t)
def dim(t: str) -> str:  return _a("2", t)
def ylw(t: str) -> str:  return _a("33", t)
def cyn(t: str) -> str:  return _a("36", t)
def bred(t: str) -> str: return _a("1;31", t)
def bgrn(t: str) -> str: return _a("1;32", t)
def bcyn(t: str) -> str: return _a("1;36", t)

def require_root() -> None:
    if os.geteuid() != 0:
        sys.exit("This script must be run as root.")

def fmt_duration(secs: float) -> str:
    secs = max(0, int(secs))
    h, rem = divmod(secs, 3600)
    m, s   = divmod(rem, 60)
    if h:   return f"{h}h {m:02d}m {s:02d}s"
    elif m: return f"{m}m {s:02d}s"
    else:   return f"{s}s"

def prep_for_format(dev_path: str) -> None:
    name = Path(dev_path).name
    sysfs = f"/sys/block/{name}/device"
    try:
        Path(f"{sysfs}/queue_depth").write_text("1")
        Path(f"{sysfs}/timeout").write_text("5")
    except OSError:
        pass

def sg_device(dev_path: str) -> str:
    name = Path(dev_path).name
    sg_dir = Path(f"/sys/block/{name}/device/scsi_generic")
    try:
        sg_name = next(sg_dir.iterdir()).name
        return f"/dev/{sg_name}"
    except (StopIteration, OSError):
        return dev_path

class Device:
    def __init__(self, path: str, port: str):
        self.path   = path
        self.port   = port
        self.slot   = PORT_TO_SLOT.get(port, "?")
        self.model  = ""
        self.serial = ""
        self.health = "?"
        self.size   = ""

    def __str__(self) -> str:
        return self.path

def discover() -> list[Device]:
    seen: set[str] = set()
    devices: list[Device] = []
    for port in PORTS:
        p = Path(port)
        if p.is_block_device():
            real = str(p.resolve())
            if real not in seen:
                seen.add(real)
                devices.append(Device(real, port))
    return devices

def enrich_lsblk(devices: list[Device]) -> None:
    paths = [d.path for d in devices]
    r = subprocess.run(
        ["lsblk", "-dn", "-o", "NAME,SIZE,SERIAL,MODEL"] + paths,
        capture_output=True, text=True,
    )
    info: dict[str, tuple[str, str, str]] = {}
    for line in r.stdout.splitlines():
        parts = line.split(maxsplit=3)
        if len(parts) >= 2:
            size   = parts[1]
            serial = parts[2].strip() if len(parts) >= 3 else ""
            model  = parts[3].strip() if len(parts) >= 4 else ""
            info[f"/dev/{parts[0]}"] = (size, serial, model)
    for dev in devices:
        dev.size, dev.serial, dev.model = info.get(dev.path, ("", "", ""))

def _health_color(health_str: str) -> str:
    try:
        val = float(health_str)
        fn  = bgrn if val >= 70 else (ylw if val >= 40 else bred)
        return fn(f"{health_str}%")
    except (ValueError, TypeError):
        return dim(health_str)

def print_table(devices: list[Device], show_health: bool = True) -> None:
    _n, _dev, _sz, _hlth, _ser, _mdl = "#", "Device", "Size", "Health", "Serial", "Model"
    print()
    if show_health:
        print(f"  {bold(f'{_n:<4}')} {bold(f'{_dev:<12}')}  "
              f"{bold(f'{_sz:<8}')}  {bold(f'{_hlth:<8}')}  "
              f"{bold(f'{_ser:<22}')}  {bold(f'{_mdl:<20}')}  {bold('Slot')}")
        print(f"  {'─'*4} {'─'*12}  {'─'*8}  {'─'*8}  {'─'*22}  {'─'*20}  {'─'*4}")
        for i, d in enumerate(devices, 1):
            h_fld    = _health_color(d.health) if d.health not in ("?", "--") else dim(d.health)
            slot_fld = cyn(str(d.slot))
            print(f"  [{i:<2}] {d.path:<12}  {d.size:<8}  {h_fld:<8}  "
                  f"{d.serial or 'N/A':<22}  {d.model or 'unknown':<20}  {slot_fld}")
    else:
        print(f"  {bold(f'{_n:<4}')} {bold(f'{_dev:<12}')}  "
              f"{bold(f'{_sz:<8}')}  {bold(f'{_ser:<22}')}  "
              f"{bold(f'{_mdl:<20}')}  {bold('Slot')}")
        print(f"  {'─'*4} {'─'*12}  {'─'*8}  {'─'*22}  {'─'*20}  {'─'*4}")
        for i, d in enumerate(devices, 1):
            slot_fld = cyn(str(d.slot))
            print(f"  [{i:<2}] {d.path:<12}  {d.size:<8}  "
                  f"{d.serial or 'N/A':<22}  {d.model or 'unknown':<20}  {slot_fld}")
    print()

def pick_devices(devices: list[Device], prompt: str) -> list[Device]:
    raw = input(bold(prompt)).strip()
    if raw.lower() == "all":
        return list(devices)
    selected = []
    for tok in raw.split():
        try:
            idx = int(tok)
            if 1 <= idx <= len(devices):
                selected.append(devices[idx - 1])
            else:
                print(f"  {ylw(f'Invalid: {tok} — skipping')}")
        except ValueError:
            print(f"  {ylw(f'Invalid: {tok} — skipping')}")
    return selected

def cmd_health(args: argparse.Namespace) -> bool:
    if not Path(HDSENTINEL).exists():
        sys.exit(bred(f"HDSentinel not found at {HDSENTINEL}"))
    devices = discover()
    if not devices:
        print(ylw("No disks connected on specified ports."))
        return False
    print(f"  {cyn('Scanning disks ...')}", flush=True)
    devlist = ",".join(d.path for d in devices)
    flags   = ["-dump"] if args.dump else []
    subprocess.run([HDSENTINEL, "-onlydevs", devlist] + flags)
    return True

def cmd_format(args: argparse.Namespace) -> bool:
    devices = discover()
    if not devices:
        print(ylw("No disks found on specified ports."))
        return False

    enrich_lsblk(devices)
    print_table(devices, show_health=False)

    selected = pick_devices(devices, "Enter device numbers to format (space-separated, 'all', or Enter to cancel): ")
    if not selected:
        return False

    fast_mode = bool(getattr(args, "fast", False))
    if not fast_mode:
        mode_in = input(bold("Format mode: [n]ormal (default) or [f]ast: ")).strip().lower()
        if mode_in in ("f", "fast"):
            fast_mode = True

    print(f"\n  {bold('Selected for formatting:')}")
    for d in selected:
        print(f"    {cyn(d.path)}  {dim(d.model or 'unknown')}  s/n: {d.serial or 'N/A'}")

    print()
    print(f"  {bred('!! WARNING:')} This will {bold('PERMANENTLY ERASE')} all data on the selected devices!")
    mode_label = "FAST format (ffmt=1)" if fast_mode else "FULL format"
    print(f"  {dim(f'Mode: {mode_label}; sg_format uses 512-byte sectors.')}")
    print()

    if input(bold("  Type YES to confirm: ")).strip() != "YES":
        log(f"FORMAT_ABORTED — devices: {' '.join(d.path for d in selected)}")
        print(ylw("\n  Aborted."))
        return False

    started: list[Device] = []
    launches: list[tuple[Device, subprocess.Popen[str]]] = []
    print()
    for d in selected:
        prep_for_format(d.path)
        print(f"  {cyn(f'==> Starting format on {d.path} ...')}")
        cmd = ["sg_format", "--format", "--size=512"]
        if fast_mode:
            cmd.append("--ffmt=1")
        cmd.append(sg_device(d.path))
        p = subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            text=True,
        )
        launches.append((d, p))

    time.sleep(0.25)
    for d, p in launches:
        rc = p.poll()
        if rc is None or rc == 0:
            started.append(d)
            mode = "fast" if fast_mode else "full"
            log(f"FORMAT_STARTED mode={mode} slot={d.slot} dev={d.path} model={d.model} serial={d.serial}")
        else:
            mode = "fast" if fast_mode else "full"
            log(f"FORMAT_START_FAILED mode={mode} slot={d.slot} dev={d.path} model={d.model} serial={d.serial}")
            print(f"    {bred('FAILED')} to start format on {d.path}")

    if not started:
        print(bred("\n  No formats were started."))
        return True

    print(f"\n  {cyn('Handing off to progress monitor ...')}")
    _progress_ui(started)
    return False

def cmd_progress(args: argparse.Namespace) -> bool:
    devices = discover()
    if not devices:
        print(ylw("No disks found on specified ports."))
        return False
    enrich_lsblk(devices)

    if args.devices:
        by_path = {d.path: d for d in devices}
        selected: list[Device] = []
        for p in args.devices:
            if p in by_path:
                selected.append(by_path[p])
            else:
                d = Device(p, "")
                r = subprocess.run(["lsblk", "-dn", "-o", "MODEL,SERIAL", p],
                                   capture_output=True, text=True)
                parts = r.stdout.strip().split(maxsplit=1)
                d.model = parts[0] if parts else ""
                d.serial = parts[1] if len(parts) > 1 else ""
                selected.append(d)
    else:
        print_table(devices, show_health=False)
        selected = pick_devices(devices, "Enter device numbers to monitor (space-separated, 'all', or Enter to cancel): ")
        if not selected:
            return False

    _progress_ui(selected)
    return False

_ANSI_ESC = re.compile(r'\033\[[0-9;]*[A-Za-z]')

def _vis_trunc(s: str, width: int) -> str:
    visible = 0
    i = 0
    result = []
    while i < len(s):
        m = _ANSI_ESC.match(s, i)
        if m:
            result.append(m.group())
            i = m.end()
            continue
        if visible >= width:
            break
        result.append(s[i])
        visible += 1
        i += 1
    if '\033' in ''.join(result):
        result.append('\033[0m')
    return ''.join(result)

class DevState:
    def __init__(self, device: Device):
        self.path          = device.path
        self.sg_path       = sg_device(device.path)
        self.slot          = device.slot
        self.model         = device.model
        self.serial        = device.serial
        self.status        = "waiting"
        self.ever_started  = False
        self.progress      = 0.0
        self.eta           = "--"
        self.start         = time.monotonic()
        self.prev_pct      = 0.0
        self.prev_time     = time.monotonic()

    @property
    def elapsed(self) -> float:
        return time.monotonic() - self.start

def _poll(state: DevState) -> None:
    if state.status in ("done", "failed"):
        return
    poll_dev = state.sg_path
    outputs: list[str] = []
    for cmd in (
        ["sg_requests", poll_dev],
        ["sg_requests", "--progress", poll_dev],
    ):
        try:
            r = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            outputs.append((r.stdout or "") + (r.stderr or ""))
        except subprocess.TimeoutExpired:
            continue

    if not outputs:
        return

    output = "\n".join(outputs)

    if re.search(r"progress indication|format in progress", output, re.I):
        pct: float | None = None
        m_pct = re.search(r"(\d+(?:\.\d+)?)\s*%", output)
        if m_pct:
            pct = float(m_pct.group(1))
        else:
            m_ratio = re.search(r"\b(\d{1,5})\s*/\s*(65535|65536)\b", output)
            if m_ratio:
                pct = (float(m_ratio.group(1)) / float(m_ratio.group(2))) * 100.0

        state.ever_started = True
        state.status       = "formatting"
        if pct is not None:
            now  = time.monotonic()
            dt   = now - state.prev_time
            dp   = pct - state.prev_pct
            state.eta       = fmt_duration((100.0 - pct) / (dp / dt)) if dt > 0 and dp > 0 else "--"
            state.prev_pct  = pct
            state.prev_time = now
            state.progress  = max(0.0, min(100.0, pct))
    elif re.search(r"error|fail", output, re.I):
        state.status   = "failed"
        state.progress = 0.0
        state.eta      = "--"
        log(f"FORMAT_FAILED slot={state.slot} dev={state.path} model={state.model} serial={state.serial}")
    elif state.ever_started:
        state.status   = "done"
        state.progress = 100.0
        state.eta      = "done"
        log(f"FORMAT_COMPLETE slot={state.slot} dev={state.path} model={state.model} serial={state.serial}")

def _progress_ui(devices: list[Device]) -> None:
    states    = [DevState(d) for d in devices]
    interval  = 5
    paused    = False
    last_poll = 0.0
    first     = True

    def draw(footer: str = "", footer_green: bool = True) -> None:
        nonlocal first
        cols = shutil.get_terminal_size(fallback=(80, 24)).columns
        out  = []
        out.append("\033[2J\033[H" if first else "\033[H")
        first = False

        def _L(content: str) -> str:
            return "\r" + _vis_trunc(content, cols - 1) + "\033[K\n"

        def _divider() -> str:
            return _L(f"{CYN}{'─' * (cols - 1)}{RST}")

        ts = time.strftime("%Y-%m-%d  %H:%M:%S")
        out.append(_L(f"{BCYN}sg_format Progress Monitor{RST}   {WHT}{ts}{RST}"))
        out.append(_divider())

        for s in states:
            elapsed_str = fmt_duration(s.elapsed)

            if s.status == "done":
                col      = BGRN
                label    = "done"
                pct_str  = "100.00%"
            elif s.status == "failed":
                col      = RED
                label    = "FAILED"
                pct_str  = "  0.00%"
            elif s.status == "waiting":
                col      = WHT
                label    = "waiting"
                pct_str  = ""
            else:
                col      = GRN if s.progress >= 50 else YLW
                label    = "formatting"
                pct_str  = f"{s.progress:6.2f}%"
            slot_str    = f"Slot {s.slot}"
            serial_str  = f"SN:{s.serial or 'N/A'}"
            left_prefix = f"  {s.path}  {slot_str}  {serial_str}  {label}  "
            right_info  = f"  Elapsed: {elapsed_str}"
            if s.status == "formatting" and s.eta != "--":
                right_info += f"  ETA: {s.eta}"

            if s.status == "formatting":
                fixed_visible = len(left_prefix) + 2 + 1 + len(pct_str) + len(right_info)
                bar_width     = max(8, min(48, cols - fixed_visible - 2))
                filled        = int(s.progress * bar_width / 100)
                bar           = "#" * filled + "." * (bar_width - filled)
                body          = f"{left_prefix}[{bar}] {pct_str}{right_info}"
            else:
                body = f"{left_prefix}{right_info.lstrip()}"

            out.append(_L(f"{col}{body}{RST}"))

        out.append(_divider())

        n_done = sum(1 for s in states if s.status == "done")
        n_fail = sum(1 for s in states if s.status == "failed")
        n_fmt  = sum(1 for s in states if s.status == "formatting")
        n_wait = sum(1 for s in states if s.status == "waiting")
        parts: list[str] = []
        if n_done: parts.append(f"{BGRN}{n_done} done{RST}")
        if n_fmt:  parts.append(f"{GRN}{n_fmt} formatting{RST}")
        if n_wait: parts.append(f"{WHT}{n_wait} waiting{RST}")
        if n_fail: parts.append(f"{RED}{n_fail} failed{RST}")
        out.append(_L(f"  {'  |  '.join(parts) or '...'}"))

        next_in = max(0, interval - int(time.monotonic() - last_poll))
        if paused:
            out.append(_L(f"  {YLW}PAUSED{RST}   Interval: {interval}s"))
        else:
            out.append(_L(f"  Interval: {interval}s   Next poll in {next_in}s"))

        if footer:
            fc = BGRN if footer_green else RED
            out.append(_L(""))
            out.append(_L(f"{fc}{footer}{RST}"))

        out.append(_L(f"  {WHT}[r]{RST} refresh   {WHT}[p]{RST} pause/resume   {WHT}[+/-]{RST} interval   {WHT}[q]{RST} quit   Ctrl+C exit"))
        out.append("\033[J")

        sys.stdout.write("".join(out))
        sys.stdout.flush()

    fd  = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    sys.stdout.write("\033[?25l")
    sys.stdout.flush()
    try:
        tty.setraw(fd)
        draw()
        while True:
            if select.select([sys.stdin], [], [], 0)[0]:
                ch = os.read(fd, 4)
                k  = ch[0:1]
                if   k in (b'q', b'Q', b'\x03', b'\x1b'):  break
                elif k in (b'p', b'P'):                      paused = not paused
                elif k in (b'r', b'R'):                      last_poll = 0.0
                elif k == b'+':                              interval = min(60, interval + 1)
                elif k == b'-':                              interval = max(1,  interval - 1)

            now = time.monotonic()
            if not paused and (now - last_poll) >= interval:
                last_poll = now
                for s in states:
                    _poll(s)

            if all(s.status in ("done", "failed") for s in states) and any(s.ever_started for s in states):
                draw("  All formatting complete.  Press q to exit.")
                while True:
                    if select.select([sys.stdin], [], [], 0.2)[0]:
                        ch = os.read(fd, 4)
                        if ch[0:1] in (b'q', b'Q', b'\x1b', b'\x03'):
                            break
                break

            draw()
            time.sleep(0.2)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
        sys.stdout.write("\033[?25h\n")
        sys.stdout.flush()

def main_menu() -> None:
    MENU = [
        ("Health check",            cmd_health,   argparse.Namespace(dump=False)),
        ("Format disks",            cmd_format,   argparse.Namespace(fast=False)),
        ("Monitor format progress", cmd_progress, argparse.Namespace(devices=[])),
    ]

    while True:
        if _TTY:
            print("\033[2J\033[H", end="", flush=True)

        print()
        print(f"  {bcyn('Disk Management Tool')}")
        print(f"  {'─' * 28}")
        print()
        for i, (label, _, _) in enumerate(MENU, 1):
            print(f"  {ylw(bold(f'[{i}]'))}  {label}")
        print()
        print(f"  {dim('[q]')}  Quit")
        print()
        print(f"  {dim('Ctrl+C at any time to exit immediately')}")
        print()

        choice = input(f"  {bold('Choose:')} ").strip().lower()
        if choice == "q":
            break
        try:
            idx = int(choice)
            if 1 <= idx <= len(MENU):
                _, fn, ns = MENU[idx - 1]
                print()
                needs_pause = fn(ns)
                if needs_pause:
                    input(f"\n  {bold('Press Enter to return to menu...')} ")
                continue
        except ValueError:
            pass
        print(f"  {ylw('Invalid choice.')}")

def main() -> None:
    require_root()

    parser = argparse.ArgumentParser(
        prog="disk",
        description="Disk health, format, and progress monitoring.",
    )
    sub = parser.add_subparsers(dest="cmd")

    p_health = sub.add_parser("health",   help="Show disk health via HDSentinel")
    p_health.add_argument("--dump", action="store_true", help="Full detailed report")

    p_fmt = sub.add_parser("format",   help="Interactive low-level format (512-byte sectors)")
    p_fmt.add_argument("--fast", action="store_true",
                       help="Use fast format mode (sg_format --ffmt=1)")

    p_prog = sub.add_parser("progress", help="Monitor sg_format progress")
    p_prog.add_argument("devices", nargs="*", metavar="DEV",
                        help="Devices to monitor (omit for interactive selection)")

    args = parser.parse_args()

    if not args.cmd:
        main_menu()
        return

    dispatch = {"health": cmd_health, "format": cmd_format, "progress": cmd_progress}
    dispatch[args.cmd](args)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
